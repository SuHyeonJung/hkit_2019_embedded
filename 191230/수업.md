## 하드웨어 제어
### Raspberry Pi Hardware
* 참고 링크
  - https://www.raspberrypi.org/documentation/hardware/raspberrypi/README.md
* Schematics(회로도)
  - https://www.raspberrypi.org/documentation/hardware/raspberrypi/schematics/README.md
* Datasheet(BCM2835 Peripheral specification)
  - https://www.raspberrypi.org/documentation/hardware/raspberrypi/bcm2835/README.md
* Peripheral Addresses
  - https://www.raspberrypi.org/documentation/hardware/raspberrypi/peripheral_addresses.md

### 실습
```c
#include <linux/module.h>
#include <linux/io.h>
#include <linux/delay.h>

volatile unsigned int* map;

static int __init mygpio_init(void)
{
    map = (volatile unsigned int*) ioremap(0x3F200000, 180);
    *map = 0x08000000;
    *(map + 7) = 0x00000200;
    msleep(2000);
    *(map + 10) = 0x00000200;

    printk(KERN_INFO "map : %p\n", map);
    printk(KERN_INFO "call mygpio_init\n");

    return 0;
}

static void __exit mygpio_exit(void)
{
    iounmap(map);
    printk(KERN_INFO "call mygpio_exit\n");
}

module_init(mygpio_init);
module_exit(mygpio_exit);

MODULE_LICENSE("GPL");
```

## 메모리 관리 장치(Memory Management Unit, 줄여서 MMU)
* MMU (메모리 관리 장치)
  - 가상 메모리 시스템을 관리하는 하드웨어 요소

* MMU 특징
  - 별도의 칩으로 된 경우도 있지만, 통상 CPU의 일부가 됨
    - MMU는 일반적으로 시스템의 가격과 복잡성을 증가시킴
    - 데스탑 PC 또는 고가의 시스템에서는, MMU를 당연히 지원하지만,  
    - 소형/저가를 위한 임베디드 시스템에서는, 통상 MMU 지원을 하지 않음

  - 작은 메모리를 갖음
    - MMU는 가상 메모리를 실제 메모리로 사상시키는데 필요한 표를 유지하도록 소량의 메모리를 갖음

* MMU 역할
  - 가상 주소를 실제 물리 주소로 변환
  - 메모리 보호를 위한 메모리 접근 제어
  - 캐시 메모리 관리
  - 버스 중재 등

* 페이지 테이블 실행 흐름도
  - ![페이지 테이블 실행 흐름도](http://thumbnail.egloos.net/600x0/http://pds20.egloos.com/pds/201906/01/38/c0246238_5cf24301799d3.png)
  - 출처 : http://egloos.zum.com/rousalome/v/9997899
* BCM2835 메모리맵
  - ![페이지 테이블 실행 흐름도](https://github.com/luibelstudy/hkit_2019_embedded/blob/master/191230/bcm2835_map.PNG?raw=true)
  
* ioremap(), iounmap()
  - 출처 : http://egloos.zum.com/Varasada/v/762505


### 파일 오퍼레이션(file_operations)
* 파일 오퍼레이션이란?
  - 디바이스 드라이버를 이해하고 사용하기 위해서는 파일 오퍼레이션 구조체에 대해 알고
있어야 한다. 문자 디바이스 드라이버와 응용 프로그램을 연결하는 고리는 파일 오퍼레이
션 구조체이다. 응용 프로그램이 저수준 파일 입출력 함수를 사용하여 디바이스 파일에
접근하면 커널은 등록된 문자 디바이스 드라이버의 파일 오퍼레이션 구조체 정보를 참고
하여 디바이스 파일에 접근한 함수에 대응하는 함수를 호출한다. 문자 디바이스 드라이버
를 등록한다는 것은 이 파일 오퍼레이션 구조체 변수를 커널에 등록하는 것을 의미한다.
이 파일 오퍼레이션 구조체는 linux/fs.h에 선언되어 있으며, 구성은 커널 2.4와 커널 2.6이
조금 다르다.
  ```c
  struct file_operations
  {
      struct module *owner;
      loff_t (*llseek)(struct file *, loff_t, int);
      ssize_t (*read)(struct file *, char __user *, size_t, loff_t *);
      ssize_t (*write)(struct file *, const char __user *, size_t, loff_t *);
      ssize_t (*aio_read)(struct kiocb *, const struct iovec *, unsigned long, loff_t);
      ssize_t (*aio_write)(struct kiocb *, const struct iovec *, unsigned long, loff_t);
      int (*readdir)(struct file *, void *, filldir_t);
      unsigned int (*poll)(struct file *, struct poll_table_struct *);
      int (*ioctl)(struct inode *, struct file *, unsigned int, unsigned long);
      long (*unlocked_ioctl)(struct file *, unsigned int, unsigned long);
      long (*compat_ioctl)(struct file *, unsigned int, unsigned long);
      int (*mmap)(struct file *, struct vm_area_struct *);
      int (*open)(struct inode *, struct file *);
      int (*flush)(struct file *, fl_owner_t id);
      int (*release)(struct inode *, struct file *);
      int (*fsync)(struct file *, int datasync);
      int (*aio_fsync)(struct kiocb *, int datasync);
      int (*fasync)(int, struct file *, int);
      int (*lock)(struct file *, int, struct file_lock *);
      ssize_t (*sendpage)(struct file *, struct page *, int, size_t, loff_t *, int);
      unsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long,
                                         unsigned long, unsigned long);
      int (*check_flags)(int);
      int (*flock)(struct file *, int, struct file_lock *);
      ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);
      ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
      int (*setlease)(struct file *, long, struct file_lock **);
  };
  ```
### 디바이스 파일
* 디바이스 파일이란?
  - 디바이스 파일은 우리가 제어하려는 하드웨어를 추상화한 대상입니다. 그렇다면 디바이스 파일은 어디에서 확인할 수 있을까요? 리눅스 시스템에서는 디바이스 파일은 "/dev" 디렉토리에 있으며 커널은 이 디렉토리에 있는 각 파일을 하드웨어라고 간주합니다. 또한 리눅스 애플리케이션은 이 디바이스 파일을 통해 하드웨어를 콘트롤합니다.
* 디바이스 파일 생성하기
  - mknod [디바이스 파일명]  [디바이스 파일형]  [주 번호]  [부 번호]
  ```console
  # mknod /dev/devicefile c 120 1
  # ls -al /dev/devicefile
  crw-rw---- 1 root root 120,   1 2019-08-23 12:09 /dev/devicefile
  ```
* 디바이스 파일 삭제
  ```console
  # rm /dev/devicefile
  ```
* 출처 : http://rousalome.egloos.com/10007389
  
